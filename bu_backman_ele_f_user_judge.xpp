
//
void bu_backman_ele_t::f_user_judge() 
{
	SOPLabel( "#m_strTitle#", "" , TITLE_X , TITLE_Y );
	SOPLabel( "#m_strInput#", "" , INPUT_X , INPUT_Y  );
	SOPLabel( "#m_Login#","" , TITLE_X , TITLE_X  );
	SOPLabel( "#UP#", "" , UP_PAGE_X , UP_PAGE_Y  );
	SOPLabel( "#DN#", "" , DN_PAGE_X , DN_PAGE_Y  );
	SOPLabel( "#CONTENT#0" , "" , CONTENT_X , CONTENT_X );
	gp_ui->LabelCommit();
	

	m_Ra3009 = a3009_t::ROWTYPE();
	m_IsJieSuan = 0;
	m_IsWeiHu = 0;


	std::string  strUser;
	std::string  strPass;
	std::string  strInput;
	std::string  str1;
	int ch;
	
	m_Scr1.clear();
	
	ShowCurrScr();

	//进入用户判断，合法登录标志清空
	if(1 == gp_medev->m_IsLegalLoginMaintenance)   //合法登入过，
	{
		bu_asynwork_t::SendReg6000ForEvent(0x03);
	}

	if(1)
	{
		if(1)
		{
			MYAUTOLOCK( gp_medev->m_DevLck );
			gp_medev->m_IsLegalLoginMaintenance = 0;
		}

		if(1)
		{
			MYAUTOLOCK( gp_coin->m_DevLck );
			gp_coin->CoinAdvice();
		}
	}
	
	gp_medev->m_legal_authority=0; //回到维护主界面 关闭权限	
	

	//开始设置超时，
	//for timeout 
	bu_quickflow_t::qf_counter_t  iQf1_user_idle;
	double iQf1_user_idleMAX = gp_db->m_a3002.GetRow(0).m_lLoginTimeout;

	int iQfFlag = 0;    // 0 - 需开始记超时    1 - 不需要再记超时
	bool fIsIllegalAlarm = false;   // true -  非法报警    false - 没有
	LOGSTREAM( gp_log[LOGSOP], LOGPOSI << "m_lLoginTimeout：" << gp_db->m_a3002.GetRow(0).m_lLoginTimeout );
	//gp_qf->GetQf( iQf1_user_idle );

L_ASK_USERNAME:

	//用户名
	do
	{
		SOPLabel( "#prompt#" , "用户名：" , CONTENT_X , CONTENT_Y + GAP * 1 * 2 );
		
		SOPLabel( "#strInput#", strInput + "_" , CONTENT_X , CONTENT_Y + GAP * 2 * 2  );

		do
		{

			if( 0 == iQfFlag && SStrf::readbit( gp_db->m_b8701.GetRow(0).m_SensorStatus.a[1], 0 ) == 1 )    // 门开，且没有设置超时
			{
				LOGSTREAM( gp_log[LOGSOP], LOGPOSI << "门开开始记超时："  );
				gp_qf->GetQf( iQf1_user_idle );

				iQfFlag = 1;
			}
			if( SStrf::readbit( gp_db->m_b8701.GetRow(0).m_SensorStatus.a[1], 0 ) == 0 )     //门关
			{
				iQfFlag = 0;
			}

			//不登录超时，则报警
			if( 1 == iQfFlag && gp_qf->IsLongQf( iQf1_user_idle , iQf1_user_idleMAX ) )
			{
				LOGSTREAM( gp_log[LOGSOP], LOGPOSI << "LoginTimeout：" );
				gp_db->m_a5041.GetRow(0).m_e.a[15] = 1;   //非法入侵
				//一直报警 到合法登入
				gp_coin->dCoinOpenAlert();
				fIsIllegalAlarm = true;
				//bu_asynwork_t::DoAlarmnSec(5);
				//gp_qf->GetQf( iQf1_user_idle );
			}

			SOPLabel( "#time#", SDte::GetNow().ReadString() , TIME_X , TIME_Y  );
			gp_ui->LabelCommit();

			this->GetInputKey(str1);
		}while( str1 == "" );

		if( str1[0] != KIN_KEYPRESS ) 
			continue;

		ch = UseChMap(SStrf::satol( str1.c_str() + 1 ));

	
		if( ch >= '0' && ch <= '9' )
		{
			if( strInput.size() > 9 )
			{
				strInput.erase( strInput.begin() );
			}
	
			strInput.append(1,(char)ch);
			
			continue;
		}

		if( ch == 27 ) // Esc
		{
			if( !strInput.empty() )
			{
				strInput.clear();
				continue;
			}
			else //已清空又再次按ESC 
			{
				SOPLabel( "#prompt#" , "" , CONTENT_X , CONTENT_X );
				SOPLabel( "#strInput#" , "" , CONTENT_X , CONTENT_X );
				continue;
			}
		}

		if( ch == 0x0d ) // CR
		{
			LOGSTREAM( gp_log[LOGSOP], LOGPOSI << "输入了用户名：" << strInput );
			strUser = strInput;
			strInput.clear();
			break;
		}

	}while(1);


	//密码 
	do
	{
		SOPLabel( "#prompt#" , "密码：" , CONTENT_X , CONTENT_Y + GAP * 1 * 2 );
		
		SOPLabel( "#strInput#", strInput + "_" , CONTENT_X , CONTENT_Y + GAP * 2 * 2  );

		do
		{
			SOPLabel( "#time#", SDte::GetNow().ReadString() , TIME_X , TIME_Y  );
			gp_ui->LabelCommit();

			this->GetInputKey(str1);
		}while( str1 == "" );

		if( str1[0] != KIN_KEYPRESS ) 
			continue;

		ch = UseChMap(SStrf::satol( str1.c_str() + 1 ));

	
		if( ch >= '0' && ch <= '9' )
		{
			if( strInput.size() > 9 )
			{
				strInput.erase( strInput.begin() );
			}
	
			strInput.append(1,(char)ch);
			
			continue;
		}

		if( ch == 27 ) // Esc
		{
			if( !strInput.empty() )
			{
				strInput.clear();
				continue;
			}
			else //已清空又再次按ESC则回 L_ASK_USERNAME	
			{
				SOPLabel( "#prompt#" , "" , CONTENT_X , CONTENT_X );
				SOPLabel( "#strInput#" , "" , CONTENT_X , CONTENT_X );
				goto 
					L_ASK_USERNAME;
			}
		}

		if( ch == 0x0d ) // CR
		{
			LOGSTREAM( gp_log[LOGSOP], LOGPOSI << "输入了密码：" << strInput );
			strPass = strInput;
			strInput.clear();
			break;
		}

	}while(1);


	bool ret = false;
	
	if( strUser == "11" && strPass == "11" )
	{
		ret = true;

		m_Ra3009.m_biIsAffect = 1;
		m_Ra3009.m_lOperatorNum = 11;
		m_Ra3009.m_OpManType = 3;
	}
	else
	{
		unsigned char binmd5[16];
		std::string m1, m2;

		md5_encode( (void*)strPass.c_str(), (int)strPass.size(), binmd5 );

		for( int iIdx1 = 0; iIdx1 < gp_db->m_a3009.ut_GetRowAmount(); iIdx1++ )
		{
			a3009_t::ROWTYPE row(gp_db->m_a3009.GetRow(iIdx1));
	
			m1 = SStrf::b2s( binmd5, 8 );
			m2 = SStrf::b2s( row.m_PIN.a, 8 );

			LOGSTREAM( gp_log[LOGSOP], LOGPOSI << "binmd5 md5=：" << m1<<" m_PIN="<<m2 );
			LOGSTREAM( gp_log[LOGSOP], LOGPOSI << "m_lOperatorNum=：" << row.m_lOperatorNum<<" strUser="<<SStrf::satoul( strUser )<<" strUser2_16="<<SStrf::satoul_16( strUser ) );

			if( ( row.m_lOperatorNum == SStrf::satoul( strUser )  || 
				row.m_lOperatorNum == SStrf::satoul_16( strUser )	) &&
				m1 == m2	)
			{
				ret = true;
				m_Ra3009 = row;
				break;
			}
		}
	}


	if( ret ) //判断账户 
	{

		SOPLabel( "#prompt#" , "输入正确。" , CONTENT_X , CONTENT_Y + GAP * 1 * 2 );
		SOPLabel( "#strInput#", "" , CONTENT_X , CONTENT_Y + GAP * 2 * 2  );
	
		//do{
		//	SOPLabel( "#time#", SDte::GetNow().ReadString() , TIME_X , TIME_Y  );
		//	gp_ui->LabelCommit();

		//	this->GetInputKey(str1);
		//}while( str1 == "" );

		SOPLabel( "#prompt#" , "" , CONTENT_X , CONTENT_X );
		SOPLabel( "#strInput#" , "" , CONTENT_X , CONTENT_X );


		m_Scr1.clear();
		m_Scr1.push_back( "输入正确" );
		ShowCurrScr();
		WThrd::tr_sleepu(0.5);
		m_Scr1.clear();

		//正确登录设定标志
		if(1)
		{
			if(1)
			{
				MYAUTOLOCK( gp_medev->m_DevLck );
				gp_medev->m_IsLegalLoginMaintenance = 1;
			}

			if(1)
			{
				MYAUTOLOCK( gp_coin->m_DevLck );
				gp_coin->CoinAdvice();
			}
		}

		//合法登入，则取消报警
		if( true == fIsIllegalAlarm  )
		{
			gp_coin->dCoinCloseAlert();
			fIsIllegalAlarm = false;
		}
		
		//合法登入 上传6000
		bu_asynwork_t::SendReg6000ForEvent(0x02);

		return;
	}
	else
	{

		//输入错误ID、密码，超时，报警
		if( 1 == iQfFlag && gp_qf->IsLongQf( iQf1_user_idle , iQf1_user_idleMAX ) )
		{
			LOGSTREAM( gp_log[LOGSOP], LOGPOSI << "LoginTimeout：" );

			//一直报警 到合法登入
			gp_coin->dCoinOpenAlert();

			fIsIllegalAlarm = true;
			//bu_asynwork_t::DoAlarmnSec(5);
			//gp_qf->GetQf( iQf1_user_idle );
		}

		SOPLabel( "#prompt#" , "输入错误！按任意键继续。" , CONTENT_X , CONTENT_Y + GAP * 1 * 2 );
		SOPLabel( "#strInput#", "" , CONTENT_X , CONTENT_Y + GAP * 2 * 2  );
	
		do{
			SOPLabel( "#time#", SDte::GetNow().ReadString() , TIME_X , TIME_Y  );
			gp_ui->LabelCommit();

			this->GetInputKey(str1);
		}while( str1 == "" );

		SOPLabel( "#prompt#" , "" , CONTENT_X , CONTENT_X );
		SOPLabel( "#strInput#" , "" , CONTENT_X , CONTENT_X );

		goto 
			L_ASK_USERNAME;
	}

}


